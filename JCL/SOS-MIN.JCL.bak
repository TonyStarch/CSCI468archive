//Z030199A JOB ,'Brandon Tweed',REGION=2M
/*JOBPARM ROOM=199,L=5
//ASSISTV EXEC PGM=ASSISTV,PARM='P=100,PX=50,R=5000,RX=3000,L=60',
// REGION=512K
//STEPLIB DD DSN=USER1.ASSIST.LOADLIB,DISP=SHR
//VIRTRDR1 DD DUMMY THIS WOULD BE INPUT ( DD * ) FOR READER X'00C'
//VIRTRDR2 DD DUMMY THIS WOULD BE INPUT ( DD * ) FOR READER X'00D'
//* VIRTPRT1 DD SYSOUT=*,DCB=RECFM=FM OUTPUT FOR PRINTER X'00E'
//* VIRTPRT2 DD SYSOUT=*,DCB=RECFM=FM OUTPUT FOR PRINTER X'00F'
//FT06F001 DD SYSOUT=* PRINTOUT FROM THE ASSEMBLY, TRACE, ETC.
//SYSPRINT DD SYSOUT=*
//SYSLIB DD DSN=SYS1.MACLIB,DISP=SHR
// DD DSN=SYS2.MACLIB,DISP=SHR
// DD DSN=T90RPR1.CS468PUB.MACLIB,DISP=SHR
//SYSIN DD *
         TITLE 'Brandon Tweed SOS-MIN'
**********************************************************************
* Brandon Tweed
* CSCI 468 Spring 2005
* SOS-A
* Due Friday Feb 11, 2005 by 12:30 pm
*
**********************************************************************
         PRINT GEN
*SYSLIB LOADERX,DSECTS,EQUREGS,EXIT,LOUNTR,FRECB100,GETCB100,WAITS
         DSECTS                       BRING IN DSECTS FOR USE
         TITLE 'START OF FIRST 4K'          
*
**********************************************************************
* START OF FIRST 4K OF STORAGE
**********************************************************************
*
FIRST4K  CSECT                        START OF FIRST4K
         USING FIRST4K,0              ESTABLISH FIRST4K ADDR
         DC    2048X'0119'            FILL 1ST WITH 'QUICK STOP'
         ORG   FIRST4K                GO BACK TO START OF 1ST 4K
         DC    X'010401190F',AL3(IPLPGM) DEFINE IPLPSW
         ORG   FIRST4K+X'10'          GO TO LOCATION FOR @(CVT)
CVT#1    DC    A(MYCVT)               ADDRESS OF MYCVT
*
*********************************************
* OLD PSWs
*********************************************
*
         ORG   FIRST4K+X'18'          GO TO LOCATION FOR OLDPSWs
OPSWEX   DC    D'0'                   OLD EXT INT PSW
OPSWSVC  DC    D'0'                   OLD SVC PSW
OPSWPC   DC    D'0'                   OLD PC PSW 
OPSWMC   DC    D'0'                   OLD MC PSW 
OPSWIO   DC    D'0'                   OLD I/O PSW
*
         ORG   FIRST4K+X'4C'          GO TO LOCATION FOR CVT#2
CVT#2    DC    A(MYCVT)               ADDRESS OF MYCVT
CLOCK    DC    F'0'                   ASSEMBLE CLOCK AS VALUE ZERO
*
********************************************
* NEW PSWs
********************************************
*
         ORG   FIRST4K+X'58'               LOCATION FOR NEW PSWS
NPSWEX   DC    X'010601190F',AL3(EXFLIH)   NEW PSW EXTERNAL
NPSWSVC  DC    X'010401190F',AL3(SVCFLIH)  NEW PSW SVC
NPSWPC   DC    X'010401190F',AL3(AFTERLOP) NEW PSW PC
NPSWMC   DC    X'010401190F',AL3(MCFLIH)   NEW PSW MACHINE CHECK
NPSWIO   DC    X'010401190F',AL3(IOFLIH)   NEW PSW I/O
*
         ORG   FIRST4K+X'A0'          LOCATION FOR LOWPSW
LOWPSW   DC    D'0'                   FILL LOWPSW WITH ZERO
*
         ORG   FIRST4K+X'B0'          LOCATION FOR LOWTIME
LOWTIME  DC    F'0'                   FILL LOWTIME WITH ZERO
*
         ORG   FIRST4K+X'BC'          MOVE TO LOCATION FOR LEVELABN
LEVELABN DC    X'0119'                SET VALUE FOR LEVELABN
LEVELFLG DC    C'X'                   LATER SET TO C'S' IN IPL
TYP1FLAG DC    C'X'                   LATER SET TO C'0' IN IPL
*
*****************************************
*  SAVE AREAS FOR INTERRUPTS
*****************************************
*
EXSAVE   DC    16CL4'EX'              SAVE AREA FOR EXTERNAL INTS
SVCSAVE  DC    16CL4'SV'              SAVE AREA FOR SVC INTERRUPTS
PCSAVE   DC    16CL4'PC'              SAVE AREA FOR PC INT.
IOSAVE   DC    16CL4'IO'              SAVE AREA FOR I/O INTERRUPTS
*
******************************************
* TCB WORDS, LOUNTR
******************************************
*
         ORG   FIRST4K+X'518'         MOVE TO LOCATION FOR TCBWORDS
TCBWORDS DC    4F'0'                  FILL TCBWORDS WITH ZEROS         
         ORG   FIRST4K+X'7E0'         MOVE TO LOCATION FOR LOUNTR
LOUNTR   DS    0H                     LABEL FOR START OF LOUNTR
         LOUNTR                       INVOKE LOUNTR MACRO
*
************************************
* SVCTABLE
************************************
*
         ORG   FIRST4K+X'2000'        MOVE TO LOCATION FOR SVC TABLE
SVCTABLE DC    16D'0'                 FILL SVC TABLE WITH ZEROS
         ORG   SVCTABLE+8*1           GO TO ENTRY FOR SVC 1
         DC    A(SVC1)                ADDRESS OF SVC 1
         ORG   SVCTABLE+8*3           GO TO ENTRY FOR SVC 3
         DC    A(SVC3)                ADDRESS OF SVC 3
         ORG   SVCTABLE+8*8           GO TO ENTRY FOR SVC 8
         DC    A(SVC8)                ADDRESS OF SVC 8
         ORG   SVCTABLE+8*15          GO TO ENTRY FOR SVC 5
         DC    X'1BFF07FE'            SR 15,15 AND BR 14
         ORG   ,                      MOVE IT FORWARD
*
*********************************************************************
* DISPATCHER
*
* ON ENTRY:
*    R3  = A(CVT)
*    R12 = A(DISPATCH)
*********************************************************************
*
         ORG   FIRST4K+X'2400'        MOVE TO DISPATCHER LOCATION
         USING DISPATCH,12            DISPATCHER ADDRESSABILITY
         USING CVT,3                  CVT ADDRESSABILITY
DISPATCH CLI   LEVELFLG,C'S'          LEVELFLAG SHOULD BE 'S'
         BNE   LEVELABN               IF NOT, DIE
         L     4,CVTHEAD              GET ADDRESS FIRST TCB
         USING TCB,4                  TCB ADDRESSABILITY
DLOOP    LTR   4,4                    CHECK TCB POINTER NOT NULL
         BZ    D0119                  IF SO, DIE
         L     5,TCBRB                GET RB ADDRESS
         USING RB,5                   RB ADDRESSABILITY
         LTR   5,5                    VERIFY RB POINTER NOT NULL
         BZ    ENDJOB                 RB POINTER NULL = END OF JOB
         CLI   RBWCF,0                CHECK WAIT COUNT FIELD = 0
         BE    DODISP                 IF SO, DISPATCH THIS TCB
         L     4,TCBTCB               IF NOT, GO TO NEXT TCB
         B     DLOOP                  CONTINUE TCB LOOP
*
* 1) save address of TCB to be dispatched into TCBWORDS+4
*
DODISP   ST    4,TCBWORDS+4           SAVE @ TCB TO BE DISPATCHED
*
* 2) Move PSW to be dispatched from RB to lowcore
*
         MVC   LOWPSW(8),RBOPSW       MOVE PSW TO BE DISPATCHED
*
* Increment dispatch count
*
         L     7,DCOUNT               GET DCOUNT
         LA    7,1(,7)                INCREMENT IT
         ST    7,DCOUNT               SAVE IT
*
* Save time of dispatch into TCB
* 
         MVC   TCBTDISP(4),CLOCK      SAVE TIME OF DISPATCH
*
* 3) Load all registers
*
         LD    0,TCBFRS+8*0           LOAD FPR 0
         LD    2,TCBFRS+8*1           LOAD FPR 2
         LD    4,TCBFRS+8*2           LOAD FPR 4
         LD    6,TCBFRS+8*3           LOAD FPR 6
         LM    0,15,TCBGRS            LOAD ALL GPRS
*
* 4) Test/set the LEVELFLG prior to departing for
*    THE SEA OF TASK
*
         CLI   LEVELFLG,C'S'          CHECK LEVELFLG IS 'S'
         BNE   LEVELABN               ABEND IF NOT
         MVI   LEVELFLG,C'T'          SET LEVELFLG TO TASK
*
* 5) Load the PSW to complete the dispatch
*
         LPSW  LOWPSW                 Load PSW to run task
*
*** BEGINNING OF ENDJOB CODE ****
*
* 1) UNCHAIN THE TCB
*
ENDJOB   L     7,TCBBACK              GET BACKWARD TCB PTR
         L     8,TCBTCB               GET FORWARD  TCB PTR
         MVC   TCBUNCH(4),UNCH        INDICATE UNCHAINED
         DROP  4                      DONE WITH CURRENT TCB
*
* UPDATE FORWARD POINTER OF PREVIOUS TCB
*
         USING TCB,7                  PREV TCB ADDR
         ST    8,TCBTCB               UPDATE FORWARD PTR
         DROP  7                      DONE WITH PREV TCB
*
* UPDATE BACK PTR OF NEXT TCB
*
         USING TCB,8                  ADDR FOR NEXT TCB
         ST    7,TCBBACK              UPDATE BACK PTR OF NEXT TCB
         DROP  8                      DONE WITH "NEXT" TCB
*
* 2) PRINT "END OF JOB" MESSAGE
*
         USING TCB,4                  REFER TO TCB UNCHAINED
         MVC   EJTCBN(8),TCBTNAME     GET TCB NAME
         MVC   EJPGMN(8),TCBPNAME     GET PROGRAM NAME
         MVC   EJWRK+12(4),TCBTCPUP   PUT TASK TIME INTO LOUNTR
         BAL   1,LOUNTR               CALL LOUNTR ON TASK TIME
EJWRK    DC    CL16'L'                LOUNTR STORAGE AREA
         MVC   EJTT(8),EJWRK          TASK TIME -> PRINT LINE
         XPRNT EJMSG,133              PRINT 1ST END JOB MSG
         XPRNT EJMSG2,133             PRINT 2ND END JOB MSG
         XOPC  25                     END WITH A DUMP     
         DROP  3,4                    DONE WITH CVT, TCB
D0119    XOPC  25                     DIE ON ERROR
*
************************************
* DISPATCHER WORKING STORAGE
************************************
*
EJMSG    DC    C'0'                   DOUBLE SPACE FOR EJMSG
         DC    CL11'SOS OF '          END JOB MESSAGE
         DC    CL14'BRANDON TWEED '   PROGRAMMER NAME
         DC    CL15' IS TERMINATING! ' MORE OF END JOB MESSAGE
         DC    92CL1' '               END JOB MESSAGE FILLER
*
EJMSG2   DC    C'0'                   CARRIAGE CONTROL
         DC    CL20'SOS TERMINATING!' TERMINATION MESSAGE
         DC    CL10'TCB NAME: '       TCB NAME
EJTCBN   DC    CL8'XXXXXXXX'          PUT TCB NAME HERE
         DC    CL11' PGM NAME: '      PGM NAME
EJPGMN   DC    CL8'XXXXXXXX'          PUT PGM NAME HERE
         DC    CL12' TASK: '          TASK TIME
EJTT     DC    CL8'XXXXXXXX'          PUT TASK TIME HERE
         DC    55CL1' '               PRINT LINE FILLER
*
UNCH     DC    CL4'UNCH'              UNCH MESSAGE FOR TCB
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32)   NICE ALIGNMENT
         DC    CL28'TOTAL DISPATCH COUNT AT LEFT'  DCOUNT MESSG
DCOUNT   DC    F'0'                   START COUNT AT ZERO
*
************************************
* CVT - COMMUNICATION VECTOR TABLE
************************************
*
         ORG   FIRST4K+X'2800'        MOVE TO LOCATION FOR THE CVT
MYCVT    DC    96X'0'                 SET UP THE CVT
         ORG   MYCVT                  GO BACK AND BEGIN DEFINING FIELDS
         DC    A(TCBWORDS)            CVTTCBP
         DC    A(SVCTABLE)            CVTSVCTA
         ORG   MYCVT+(CVTC100H-CVT)   LOCATION FOR CVTC100H
         DC    A(CB100HDR)            HEADER ADDRESS CB100s (CVT100H)
         DC    A(DISPATCH)            (CVT0DS) ADDRESS OF DISPATCHER
         ORG   MYCVT+(CVTMSECB-CVT)   LOCATION FOR CVTMSECB
         DC    A(LOCMECB)             ADDRESS FOR MSECB
         ORG   MYCVT+(CVTMSDAT-CVT)   LOCATION FOR CVTMSDAT
         DC    A(MYMSDA)              ADDRESS FOR MYMSDA
         SVC   3                      SVC 3
         BCR   15,14                  CVTBRET
         ORG   MYCVT+(CVTIDENT-CVT)   LOCATION FOR IDENT
         DC    CL4'CVT '              INSERT THE CVT IDENT
         ORG   ,                      MOVE ON
         TITLE 'IPL ROUTINE DOC' 
*
**********************************************************************
* IPLPGM
*
* INPUT:  NONE
*
* OUTPUT: A MESSAGE THAT STATES THE VALUE SAVED FOR CVTMZ00
*
* ENTRY CONDITONS: None
*
* EXIT CONDITIONS: System setup as described in IPL handout
*
* REGISTER USAGE:
*
*    R0 -  ADDRESS OF LOWEST STORAGE AREA IN MEMORY (FOR TRACING)
*    R1 -  HIGHEST ADDRESS IN THE ASSEMBLY (FOR TRACING)
*          ALSO USED BY LOUNTR
*    R2 -  ASSISTV TRACE TYPE CODES
*    R3 -  CVT ADDRESSABILITY
*    R6 -  USED IN PERFORMING LOGICAL COMPARISONS
*          (FOR THE SOC5 AND THE ADDRESS OF SOC5 INSTRUCTION)
*    R7 -  HOLDS STORAGE KEY OF ZERO
*    R8 -  HOLD ADDRESS TO SET STORAGE KEY VALUE
*    R12 - USED FOR IPLPGM ADDRESSABILITY
*
* LOGIC:
*
* 1) Set up addressability based upon R12
* 2) Set the clock to X'50' to the value X'7FFFFFF'
* 3) Turn on the Assist-V Trace Facility
* 4) 4.1) Set all of the 2K blocks of memory with a protection byte of
*         X'00'
*    4.2) Check that a SOC5 caused the program check interrupt
*    4.3) Make sure address of instruction causing SOC5 is in 
*         old program check PSW
*    4.4) Print the value of CVTMZ00
*
**********************************************************************
         TITLE 'IPL ROUTINE CODE'
         ORG   FIRST4K+X'3000'        MOVE TO THE IPL ROUTINE
* 
* 1. Set up Addressability based on R12
*
IPLPGM   BALR  12,0                   Put ani into R12
         BCTR  12,0                   Decrement R12 by 1
         BCTR  12,0                   Decrement again
         USING IPLPGM,12              Now R12 points to start of IPLPGM
*
* 2. Set the Clock (X'50') to X'7FFFFFF'
*
         MVC   CLOCK(4),TIMEVAL       set value for clock
*
* 3. Turn on the Assist-V Trace Facility
*
         LM    0,2,R0R1R2             load regs to set trace
         XOPC  3                      turn on trace 
*
* 4. Set all of the 2K blocks of memory with a
*    protection byte of X'00'
*
         XR    7,7                    R7 will be R1, ZERO IT
         XR    8,8                    R8 will be R2, ZERO IT
LOOP     SSK   7,8                    Set Storage Key to 0
POINTHER LA    8,X'800'(,8)           increment RB b 2K
         B     LOOP                   continue infinite loop
AFTERLOP MVC   NPSWPC+5(3),REALPC+1   put @(PCFLIH) into PC New PSW
*
* Check that it was a SOC5 that caused the Program Check
*
         CLI   OPSWPC+3,5             See if int code was 5 (FOR SOC5)
         BNE   IPL0119                If not, stop
*
* Test if @(POINTHER) in old PC PSW
*
         LA    6,POINTHER             Get @POINTHER
         CLM   6,7,OPSWPC+5           If inst. addr in PSW POINTHER
         BNE   IPL0119                No, then stop
*
         L     3,76                   Get @CVT
         USING CVT,3                  CVT addressability
         BCTR  8,0                    Decrease HIGHEST by 1
         ST    8,CVTMZ00              Save HIGHEST address
*
* Print the value of CVTMZ00
*
         MVC   LSTOR+12(4),CVTMZ00    Put CVTMZ00 into LOUNTR stor
         BAL   1,LOUNTR               LOUNTR translates CVTMZ00
LSTOR    DC    CL16'L'                Storage for LOUNTR
         MVC   OUTVAL(8),LSTOR        Put value in print line
         XPRNT MESSAGEO,20            print value of CVTMZ00
*
* 5) Chain the 15 CB100 blocks and establish the CB100 header
*
         L 10,ADCBPOOL                GET ADDRESS OF POOL
         LA 0,CB100#                  GET # OF CB100S
CBATIPL  FRECB100            
         LA 10,CB100LTH(10)           MOVE TO THE NEXT 
         BCT 0,CBATIPL                DECREMENT # OF BLOCKS AND LOOP
*
* 6) Get CBs and chain them
*
* GET TCB FOR MS/NMI
*
         GETCB100
         LR    7,10                   PUT @ NMS TCB IN 7
         ST    7,CVTHEAD              SAVE @ NMS TCB INTO CVTHEAD
         USING TCB,7                  SET UP TCB ADDRESSABILITY
         XC    TCB(CB100LTH),TCB      CLEAR CB CONTENTS
         MVC   TCBTNAME(8),TCBTNVAL   SET TCBTNAME EXCEPT FOR 'n'
         MVI   TCBTNAME+3,C'M'        BECAUSE THIS IS THE MS/NMI TCB
         MVC   TCBIDENT(3),IDENTVAL   SET TCBIDENT 
         MVC   TCBGRS(8),GRSVAL       SET UP TCBGRS INIT VALUE
         MVC   TCBGRS+8(56),TCBGRS    REPEAT VALUE
*
* GET RB FOR MS/NMI
*
         GETCB100 
* Pause - set the TCBRB field for the MS TCB
         ST    10,TCBRB               Set the TCBRB field
         LR    8,10                   GET @(MS/NMI) RB INTO R8                
         USING RB,8                   NOW WORK WITH THE RB
         XC    RB(CB100LTH),RB        CLEAR THE RB
         MVC   RBTYPE(4),RBTYPVAL     SET RBTYPE
         ST    7,RBTCB                POINT RBTCB AT TCB FOR MS/NMI
         OI    RBFLGS3,X'80'          SET BIT 0 TO 1 FOR A PRB
         MVC   RBOPSW(8),RB0PSW1      PSW FOR NIP/MS RB
         MVC   RBGRSAVE(8),RBGRSAV    SET RBGRSAVE TO INIT VALUE
         MVC   RBGRSAVE+8(56),RBGRSAVE REPEAT THIS VALUE
         MVC   RBFRSAVE(8),RBFRSAV    SET RBFRSAVE TO INIT VALUE
         MVC   RBFRSAVE+8(24),RBFRSAVE REPEAT THE VALUE
         STCM  7,7,RBLINK+1           SET RBLINK FIELD TCB
         DROP  8                      Done with this RB for now
*
* GET TCB FOR WAIT
*
         GETCB100
         LR    9,10                   GET @ WAIT TCB INTO R9
* Hold it! Update the "Next" field of the NMS TCB
         ST    9,TCBTCB               SAVE @ WAIT TCB IN NMS TCB
         DROP  7                      Done with NMS TCB 
* -Back to setting up the Wait TCB-
         USING TCB,9                  SET UP ADDR TO WAIT TCB
         XC    TCB(CB100LTH),TCB      CLEAR CB CONTENTS
         MVC   TCBTNAME(8),TCBTNVAL   SET TCBTNAME EXCEPT FOR 'n'
         MVI   TCBTNAME+3,C'W'        BECAUSE THIS IS THE WAIT TCB
         MVC   TCBIDENT(3),IDENTVAL   SET TCBIDENT
         MVC   TCBGRS(8),GRSVAL       SET UP TCBGRS INIT
         MVC   TCBGRS+8(56),TCBGRS    REPEAT VALUE
         ST    7,TCBBACK              SET TCB BACKWARD PTR TO MS/NMI     
*
* GET RB FOR WAIT
* 
         GETCB100
         USING RB,10                  SET UP WAIT RB ADDRESSABILITY
*
* Pause - Set TCBRB in the WaitTCB
*
         ST    10,TCBRB               Set TCB pointer in Wait TCB
         DROP  9                      Done with Wait TCB
         XC    RB(CB100LTH),RB        CLEAR CB CONTENTS
         MVC   RBTYPE(4),RBTYPVAL     SET RBTYPE
         ST    9,RBTCB                POINT RBTCB AT TCB FOR WAIT
         OI    RBFLGS3,X'80'          SET BIT 0 TO 1 FOR A PRB
         MVC   RBOPSW(8),RB0PSW2      PSW FOR WAIT
         MVC   RBGRSAVE(8),RBGRSAV    SET RBGRSAVE TO INIT VALUE
         MVC   RBGRSAVE+8(56),RBGRSAVE REPEAT THIS VALUE
         MVC   RBFRSAVE(8),RBFRSAV    SET RBFRSAVE TO INIT VALUE
         MVC   RBFRSAVE+8(24),RBFRSAVE REPEAT THE VALUE
         STCM  9,7,RBLINK+1           SET RBLINK FIELD TO TCB
         DROP  10                     DONE WITH WAIT RB
*
* 7) Load address of dispatcher and branch to it
*
         MVI   LEVELFLG,C'S'          LEVELFLG TO 'S' FOR SYSTEM
         MVI   TYP1FLAG,C'0'          TYP1FLAG TO 0
         L     12,CVT0DS              GET DISPATCHER ADDRESS
         BR    12                     BRANCH TO THE DISPATCHER
         DROP  3                      Done with the CVT
*
IPL0119  XOPC  25                     Die if anything goes wrong
         TITLE 'IPL ROUTINE STORAGE AREA'
*
**********************************************************************
* IPL PROGRAM STORAGE AREA
**********************************************************************
*
R0R1R2   DC    F'0'                   SET 'LOWEST' AREA TRACED ZERO
         DC    A(HIGHEST)             SET 'HIGHEST' AREA TRACED 'TOP'
         DC    XL4'00E08040'          TRACE CH. 0-1-2, SWAPS, PRIVOPS
TIMEVAL  DC    X'7FFFFFFF'            VALUE FOR SETTING THE CLOCK
REALPC   DC    A(PCFLIH)              ACTUAL ADDRESS OF PC FLIH
*
MESSAGEO DC    C' '                   CC FOR MESSAGEO
         DC    CL11'CVTMZ00 is '      FIRST PART OF MESSAGE
OUTVAL   DC    CL8' '                 CVTMZ00 VALUE ON PRINT LINE
ADCBPOOL DC    A(CB100POL)            ADDRESS OF THE CB100 BLOCK POOL
TCBTNVAL DC    CL8'TCBn BDT'          For initializing TCBTNAME
IDENTVAL DC    CL3'TCB'               For setting up TCBIDENT
GRSVAL   DC    CL8'TCBGRS'            For setting up TCBGRS
FRSVAL   DC    CL8'TCBFRS'            For setting up TCBFRS
RBTYPVAL DC    CL4' PRB'              USED TO SET UP RBTYPE
RBGRSAV  DC    CL8'RBGRSAVE'          USED TO SET UP RBGRSAVE
RBFRSAV  DC    CL8'RBFRSAVE'          USED TO SET UP RBFRSAVE
*
RB0PSW1  DC    X'FF0401190F',AL3(NIPMS)    PSW FOR NIP/MS RB
RB0PSW2  DC    X'FFE601190F',AL3(LEVELABN) PSW FOR WAIT RB
*
         ORG   FIRST4K+X'4000'        GO TO PLACE FOR FLIHs         
EXFLIH   DC    X'0119'                EXTERNAL FLIH
*
********************************************************************
* SVC FIRST LEVEL INTERRUPT HANDLER
*
* LOGIC:
* 1)  SAVE ALL GPRS IN SVCSAVE
* 2)  ESTABLISH CVT ADDRESSABILITY
* 3)  ESTABLISH TCB ADDRESSABILITY
* 4)  MOVE ALL GPRS TO THE TCB
* 5)  SAVE ALL FPRS INTO THE TCB
* 6)  GET RB ADDRESS FROM TCB INTO R5
* 7)  VERIFY RB ADDRESS NOT ZERO
* 8)  COPY OLD PSW TO INTO THE RB
* 9)  <PERFORM SVC INT. FUNCTIONS> - SEE BELOW
* 10) BRANCH TO DISPATCHER W/ R3 STILL VALID
* 
* STEP 9 IN DETAIL:
*
* A) GET THE INTERRUPT CODE FROM THE OLDPSW
* B) MAKE SURE CODE IS IN RANGE OF SVCTABLE
* C) IF SVC IS TYPE 1 THEN
* D)    TEST AND SET FLAG TO INDICATE 'TYPE 1'
* E)    GO TO SVC ROUTINE
* F)    TEST AND RESET FLAG TO INDICATE NOT TYPE 1
* E)    STORE REGS 0,1,15 IN TCBGRS AREA
* F) ENDIF
*
* REGISTER USAGE:
*
* R0,R1,R13,R15 - Used by SVC, shouldn't be altered
* R3 - CVT ADDRESSABILITY
* R4 - TCB ADDRESSABILITY
* R5 - RB ADDRESSABILITY
* R6 - A(SVC ROUTINE TO CALL)
* R7 - INTERRUPT CODE FROM OLD PSW
* R8 -  USED IN CALCULATING TCBTCPUP and TCBTCPUS
*       A(SVCTABLE)
* R12 - SVCFLIH ADDRESSABILITY
* R14 - RETURN ADDRESS FROM SVC ROUTINE
*
*********************************************************************
         TITLE 'SVCFLIH CODE'
SVCFLIH  CLI   LEVELFLG,C'T'          CHECK IF IN TASK STATE
         BNE   LEVELABN               IF NOT, SOMETHING WRONG, DUMP
         MVI   LEVELFLG,C'S'          OTHERWISE SWITCH TO SYSTEM STATE
*
* Move clock to a lowcore location
*
         MVC   LOWTIME(4),CLOCK       GET VALUE OF CLOCK INTO LOWTIME
*
* Save all GPRs in SVCSAVE
*
         STM   0,15,SVCSAVE           SAVE GPRS IN PROPER SAVE AREA
*
* Establish CVT addressability
*
         L     3,76                   GET @ OF THE CVT
         USING CVT,3                  ESTABLISH CVT ADDRESSABILITY
*
* Establish TCB addressability
*
         L     4,TCBWORDS+4           GET @ CURRENTLY DISPATCHED TCB
         USING TCB,4                  ESTABLISH TCB ADDRESSABILITY
*
* MOVE ALL GPRS TO THE TCB         
*
         MVC   TCBGRS(16*4),SVCSAVE   MOVE GPRS INTO THE TCB
*
* SAVE ALL FPRS INTO THE TCB
*
         STD   0,TCBFRS               STORE FPR 0
         STD   2,TCBFRS+8             STORE FPR 2
         STD   4,TCBFRS+16            STORE FPR 4
         STD   6,TCBFRS+24            STORE FPR 6
*
* Establish Routine Addressability so we can access
* SVCF0119
*
         BALR  12,0                   GET ADDRESS NEXT INSTRUCTION
         USING *,12                   ESTABLISH SVCFLIH ADDRESSABILITY
*
* Establish RB addressability
*
         L     5,TCBRB                GET @ OF CURRENTLY DISPATCHED RB
         USING RB,5                   ESTABLISH RB ADDRESSABILITY
*
* Verify RB address not null
*
         LTR   5,5                    TEST R5
         BZ    SVCF0119               IF IT IS, DIE!!!         
*
* COPY OLD PSW TO INTO THE RB
*
         MVC   RBOPSW(8),OPSWSVC      MOVE OLD PSW INTO THE RB
*
* Calculate accumulated task time
*
         L     8,TCBTDISP             GET TIME OF DISPATCH
         S     8,LOWTIME              SUBTRACT THE CURRENT TIME
*
* Test to see if PSW was in supervisor or problem state
*
         TM    OPSWSVC+1,X'01'        Check if PSW in SV State
         BZ    SVTIME                 If in SV state, ad SV time
         A     8,TCBTCPUP             ADD ACCUMULATED TASK CPU         
         ST    8,TCBTCPUP             SAVE ACCUMULATED TASK TIME
         B     STEP9A                 Move on to STEP9A
SVTIME   A     8,TCBTCPUS             Add accum. SV TIME
         ST    8,TCBTCPUS             Update the SV TIME in TCB
*
* <PERFORM SVC INTERRUPT FUNCTIONS>
*
* A) GET THE INTERRUPT CODE FROM THE OLDPSW
*
STEP9A   LH    7,OPSWSVC+2            GET INTERRUPT CODE INTO R7
*
* B) MAKE SURE CODE IS IN RANGE OF SVCTABLE
*
         SLL   7,3                    MULTIPLY INT CODE * DISPLACEMENT
         L     8,CVTSVCTA             GET @ OF SVCTABLE
         AR    7,8                    GET @ OF ENTRY INTO R7
         LA    8,128(,8)              GET @ OF END OF SVC TABLE
         CR    7,8                    CHECK IF IN RANGE OF TABLE
         BNL   SVCF0119               IF NOT, DUMP OUT
         L     6,0(,7)                GET @ OF SVC ROUTINE
         LTR   6,6                    Check if address null
         BZ    SVCF0119               IF IT'S ZERO, DIE
*        
* TEST AND SET FLAG TO INDICATE 'TYPE 1'
*
         CLI   TYP1FLAG,C'0'          CHECK THE TYPE 1 FLAG
         BNE   SVCF0119               IF IT'S NOT C'0', DUMP
         MVI   TYP1FLAG,C'1'          SET THE TYPE 1 FLAG TO '1'
*
* GO TO SVC ROUTINE
*
         BALR  14,6                   GO TO THE SVC ROUTINE
*
* TEST AND RESET FLAG TO INDICATE NOT TYPE 1
*
         CLI   TYP1FLAG,C'1'          CHECK THE TYPE 1 FLAG
         BNE   SVCF0119               IF IT'S NOT '1', DUMP
         MVI   TYP1FLAG,C'0'          SET IT TO '0'
*
* STORE REGS 0,1,15 IN TCBGRS AREA
*
         STM   0,1,TCBGRS             SAVE R0 AND R1 IN TCBGRS
         ST    15,TCBGRS+15*4         SAVE R15 IN TCBGRS
*
* Branch back to the Dispatcher
*         
         L     12,CVT0DS              Get @ of the Dispatcher
         BR    12                     Branch back to it  
SVCF0119 XOPC  25                     DIE IF SOMETHING GOES BAD
*
***************************
* SVCFLIH storage
***************************
*
*
***************************
* END OF SVCFLIH
***************************
*
PCFLIH   DC    X'0119'                PROGRAM CHECK FLIH
MCFLIH   DC    X'0119'                MACHINE CHECK FLIH
IOFLIH   DC    X'0119'                I/O FLIH
*
****************************************
* SVC AREA
****************************************
*
        ORG    FIRST4K+X'6000'        GO TO SVC 1
SVC1    DS     0H                     ADDRESS OF SVC 1
        WAITS
        ORG    FIRST4K+X'7000'        GO TO SVC 3
SVC3    DS     0H                     ADDRESS OF SVC 3
        EXIT
        ORG    FIRST4K+X'7300'        GO TO SVC 8
SVC8    DS     0H                     ADDRESS OF SVC 8
        LOADERX
*
****************************************
* CONTROL BLOCKS OBTAINED DYNAMICALLY 
****************************************
*
         ORG   FIRST4K+X'110E0'       MOVE TO LOCATION FOR CB100s
CB100LTH EQU   X'100'                 LENGTH OF THE CONTROL BLOCKS
CB100#   EQU   15                     NUMBER OF CB100 BLOCKS
CB100HDR DC    A(0)                   NULL PTR
         DC    CL28'THE CB100 POOL FOLLOWS THIS'  DEFINE CB100HDR
CB100POL DC   (CB100#)CL(CB100LTH)'1234-BRANDON TWEED-UNUSED CB' INIT
         ORG   ,                      MOVE ON         
*
****************************************
* NIP/MS (MASTER SCHEDULER)
*
* REGISTERS:
*  3 - CVT ADDRESSABILITY
*  8 - MSDA ADDRESSABILITY
* 12 - NIP/MS ADDRESSABILITY
*
****************************************
*
         ORG   FIRST4K+X'12000'       MOVE TO LOCATION FOR NIP/MS
NIPMS    BALR  12,0                   SET UP ADDRESSABILITY
         BCTR  12,0                   BACK ONE
         BCTR  12,0                   BACK ONE
         USING NIPMS,12               ESTABLISH NIPMS ADDR
         LA    8,MYMSDA               GET ADDDRESS OF MSDA
         USING MSDA,8                 ADDR FOR MSDA
         L     3,76                   GET A(CVT)
         USING CVT,3                  ADDR FOR CVT
MSWAITLP LA    1,MSDAMECB             GET A(MECB)
         SVC   1                      CALL 'WAIT'
         CLC   MSDAMECB(4),X7FDIS     COMPARE MECB WITH X'7F'C'DIS'
         BNE   MS0119                 IF NOT CORRECT, DIE
CURVSMAX L     0,MSDACURI             CHECK CURRENT INITIATOR
         C     0,MSDAMAXI             COMPARE TO MAX INITIATORS
         BNL   DOMSWAIT               IF CURI <= MAXI, WAIT
         XREAD BUFFER,80              GET THE PARM CARD
         BZ    RUNJOB                 IF READ OK, DO RUNJOB CODE
         LTR   0,0                    IF VALUE IS ZERO
         BZ    MS0119                 NO MORE JOBS, DIE
         B     DOMSWAIT               IF NOT, WAIT
*
*** START OF "RUN JOB" CODE
*
* 1) Obtain address of region where program is to be run
*
RUNJOB   L     4,MSDAFLAD             Get @ REGION
*
* 2) Get pad character and set 4096 bytes of region
*
         L     5,FOURK                GET 4K
         IC    7,MSDAFPAD             INSERT PAD BYTE
         SLL   7,24                   SHIFT PAD BYTE IN REG
         MVCL  4,6                    FILL USER REGION
*
* 3) obtain key and fetch protect and perform 2 SSKs
*
         L     4,MSDAFLAD             GET @ USER REGION
         IC    9,MSDAFKEY             GET KEY 
         SSK   9,4                    SET KEY FOR REGION
         LA    4,2048(,4)             MOVE TO NEXT 2K
         SSK   9,4                    SET KEY FOR 2ND PART
*
* 4) MOVE 80 BYTES OF THE PARM TO END OF USER REGION
*    SAVE ADDRESS OF PARM POINTER
* 
*         LA    4,4096-80              GET DISPLACEMENT OF 80 BYTES
*         A     4,MSDAFLAD             RESOLVE DISPLACEMENT
*         MVC  0(80,4),BUFFER         COPY BUFFER CONTENTS
*         S    4,PTRLEN               STEP BACK TO POINTER START
*         ST   4,PARMPTR              SAVE PARM AREA POINTER
*         MVC  0(8,4),PRMBYTES        SET UP "POINTER"
*         LA   5,6(,4)                GET @ HALFWORD LENGTH
*         STCM 5,7,1(4)               SAVE @ HALFWORD LENGTH
*         LA   5,80                   GET 80 INTO R5
*         STC  5,0(4)                 SAVE HALFWORD LENGTH
*         MVI  87(4),0                ZERO LAST BYTE OF BUFFER
*
* 5) Set up an 18F save area and set the 2nd FW to zero
*    Save the address of this SA
*
         LA    4,4096-72              Calc disp of SA
         A     4,MSDAFLAD             Add to region address
         ST    4,SAPTR                SAVE POINTER TO SA
         XC    4(4,4),4(4)            CLEAR 2ND FULLWORD
*
* 6) Load the user's program into the 4K region
*
         L     0,MSDAFLAD             GET @ LOAD LOCATION
         SR    4,0                    CALC AVAILABLE SPACE
         LR    1,4                    SET R1 = AVAILABLE SPACE
         SVC   8                      CALL THE LOADER
         LTR   15,15                  CHECK RETURN CODE
         BNZ   MS0119                 IF NOT ZERO, DIE
         ST    0,EPAPTR               SAVE ENTRY POINT ADDRESS
         ST    1,MODLEN               SAVE MODULE LENGTH
*
* 7) OBTAIN AND CONFIGURE TCB AND RB
*
        GETCB100
        LR     9,10                   GET A(TCB) into R9
        USING  TCB,9                  TCB ADDR
        XC     TCB(CB100LTH),TCB      CLEAR THE TCB
        MVC    TCBTNAME(8),TNAME      SET TCBTNAME
        MVI    TCBTNAME+3,C'1'        SET # FOR TCBTNAME
        MVC    TCBIDENT(4),TIDENT     SET TCBIDENT
        IC     10,IDNTNUM             GET NUM FOR TCBIDENT
        STC    10,TCBTNAME+3          SAVE IDENT CHARACTER
        LA     10,1(,10)              INCREMENT IDENT NUM
        STC    10,IDNTNUM             SAVE UPDATED IDENT NUM
        MVC    TCBGRS(8),TGRS         SET TCBGRS
        MVC    TCBGRS+8(56),TGRS      RIPPLE TCBGRS
        MVC    TCBFRS(8),TFRS         SET TCBFRS
        MVC    TCBFRS+8(24),TFRS      RIPPLE TCBFRS
        MVC    TCBGRS+1*4(4),PARMPTR  SET R1= PARM POINTER
        MVC    TCBGRS+13*4(4),SAPTR   SET R13 = SAVE AREA
        MVC    TCBGRS+15*4(4),EPAPTR  SET R15 = EPA
        LA     11,CVTEXIT             GET A(CVTEXIT)
        ST     11,TCBGRS+4*14         SAVE A(CVTEXIT)
        MVC    TCBAPARM(4),PARMPTR    SET UP A(PARM) IN TCB
        MVC    TCBFSA(4),SAPTR        SET UP SAVE AREA PTR IN TCB
        L      1,EPAPTR               GET EPA
        MVC    TCBPNAME(8),5(1)       GET PROGRAM NAME FROM EPA+5
*
* GET THE RB AND CONFIGURE IT
*
        GETCB100
        USING  RB,10                  ESTABLISH RB ADDR
        XC     RB(CB100LTH),RB        CLEAR THE RB
        ST     9,RBTCB                SET RBTCB TO POINT TO TCB
        ST     10,TCBRB               SET UP TCBRB TO POINT TO RB
        MVC    RBTYPE(4),RTYPE        SET RBTYPE
        OI     RBFLGS3,X'80'          SET BIT 0 TO 1 (PRB)
        MVZ    NEWPSW+1(1),MSDAFKEY   LEFT HIT OF KEY INTO PSW
        L      1,EPAPTR               GET EPA
        STCM   1,7,NEWPSW+5           SET ADDRESS IN PSW
        MVC    RBOPSW(8),NEWPSW       PUT NEW PSW IN PRB
        MVC    RBGRSAVE(8),RGRS       INIT RB GRS
        MVC    RBGRSAVE+8(56),RGRS    RIPPLE INIT VALUE
        MVC    RBFRSAVE(8),RFRS       INIT RB FRS
        MVC    RBFRSAVE+8(24),RFRS    RIPPLE INIT VALUE
        STCM   9,7,RBLINK+1           POINT RBLINK TO TCB
        DROP   9,10                   DONE WITH TCB & PRB FOR NOW
*
* 8) BUILD A JOB START MESSAGE AND PRINT IT OUT
*
         MVC   LACALL+12(4),EPAPTR    MOVE LOAD ADDRESS INTO LOUNTR
         BAL   1,LOUNTR               CALL LOUNTR
LACALL   DC    CL16'L'                LOUNTR STORAGE
         MVC   JSLAOUT(8),LACALL      GET LOAD ADDRESS TO PLINE
         MVC   LACALL2+12(4),MODLEN   PUT MODULE LENGTH INTO LOUNTR
         BAL   1,LOUNTR               CALL LOUNTR
LACALL2  DC    CL16'L'                STORAGE FOR SECOND LOUNTR
         MVC   JSPLOUT(8),LACALL2     GET PRINTABLE MODULE LENGTH
         L     4,EPAPTR               GET EPA
         MVC   JSPNAME(8),5(4)        GET PROGRAM NAME FROM EPA+5
         USING TCB,9                  ADDRESS TCB
         MVC   JSTCBN(8),TCBTNAME     GET TCB NAME ONTO PRINT LINE
         DROP  9                      DONE WITH TCB
         XPRNT JSMESSG,133            PRINT THE JOB START MESSAGE
*
* 9) UPDATE VALUES IN THE MSDA
*
         L     4,FOURK                GET 4K
         A     4,MSDAFLAD             ADD 4K TO USER REGION START
         ST    4,MSDAFLAD             SAVE UPDATED REGION START
         LA    4,1                    FOR ADDING TO PAD
         A     4,MSDACURI             INCREMENT CURI BY 1
         ST    4,MSDACURI             SAVE UPDATED CURI VALUE
         IC    5,MSDAFPAD             GET PAD VALUE
         LA    5,1(,5)                INCREMENT PAD CHARACTER
         STC   5,MSDAFPAD             SAVE UPDATED PAD CHARACTER
         IC    5,MSDAFKEY             GET KEY VALUE
         LA    5,16(,5)               INCREMENT BY X'10'
         STC   5,MSDAFKEY             SAVE UPDATED KEY VALUE
*
* 10) chain user's TCB into the chain following NIP/MS TCB
*
         USING TCB,9                  ESTABLISH TCB ADDRESSABILITY
         L     10,CVTHEAD             GET START TCB CHAIN
         ST    10,TCBBACK             SAVE BACKWARD POINTER
         DROP  9                      DONE WITH NEW TCB
         USING TCB,10                 DEAL WITH MS TCB
         L     11,TCBTCB              GET MSTCB FORWARD POINTER
         ST    9,TCBTCB               ST MSTCB FORWARD POINTER TO NEW
         DROP  10                     DONE WITH MS TCB
         USING TCB,9                  ESTABLISH NEW TCB ADDR
         ST    11,TCBTCB              UPDATE NEW TCB FORWARD POINTER
         DROP  9                      DONE WITH NEW TCB
         USING TCB,11                 ADDRESSABILITY TO LAST TCB
         ST    9,TCBBACK              UPDATE BACKWARD POINTER
         DROP  11                     DONE WITH LAST TCB
*
* 11) BRANCH TO CURVSMAX
*
         B     CURVSMAX               RETURN TO CURVSMAX
DOMSWAIT XC    LOCMECB(4),LOCMECB     CLEAR MECB
         B     MSWAITLP               GO BACK TO MS WAIT LOOP
MS0119   XOPC  25                     MASTER SCHEDULER BAIL POINT
         DROP  3,8,12                 DONE WITH CVT,MSDA,MSNIP    
*
********************************************************************
* MS/NIP WORKING STORAGE
********************************************************************
*
TNAME    DC    CL8'TCBn BDT'          NEW TCB NAME VALUE
TIDENT   DC    CL4'TCB '              NEW TCB IDENT 
TGRS     DC    CL8'TCBGRS'            NEW TCB GRS INIT VALUE
TFRS     DC    CL8'TCBFRS'            NEW TCB FRS INIT VALUE
RTYPE    DC    CL4' PRB'              NEW RB RBTYPE VALUE 
RGRS     DC    CL8'RBGRSAVE'          RB GRS INIT VALUE
RFRS     DC    CL8'RBFRSAVE'          RB FRS INIT VALUE
IDNTNUM  DC    C'1'                   FOR INITIALIZING TCBIDENT
NEWPSW   DC    XL5'FF0501190F'        FIRST PART OF PSW
         DC    AL3(0)                 ADDRESS PART OF PSW
X7FDIS   DC    X'7F',C'DIS'           FOR CHECKING MECB
BUFFER   DC    80C'Z'                 READ BUFFER
*
FOURK    DC    F'4096'                FOUR K
PTRLEN   DC    F'8'                   8 BYTES FOR POINTER
SAVLEN   DC    F'72'                  72 BYTE SAVE AREA
PARMPTR  DC    A(0)                   POINTER TO PARM AREA
EPAPTR   DC    A(0)                   ENTRY POINT ADDRESS
MODLEN   DC    F'0'                   MODULE LENGTH
SAPTR    DC    A(0)                   SAVE AREA POINTER
PRMBYTES DC    XL8'800000000000004F'  PARM POINTER BYTES 
*
JSMESSG  DC    C' '                   SINGLE SPACE
         DC    CL20'OS OF BRANDON TWEED ' JOB START MESSAGE
         DC    CL4'LA: '              LOAD ADDRESS
JSLAOUT  DC    CL8'XXXXXXXX'          JOB START LOAD ADDRESS
         DC    CL17' PROGRAM LENGTH: ' JOB START MESSAGE
JSPLOUT  DC    CL8'XXXXXXXX'          JOB START PROGRAM LENGTH
         DC    CL8' BYTES. '          JOB START MESSAGE
         DC    CL10'PGM NAME: '       JOB START MESSAGE
JSPNAME  DC    CL8'XXXXXXXX'          PROGRAM NAME 
         DC    CL11' TCB NAME: '      JOB START MESSAGE
JSTCBN   DC    CL8'XXXXXXXX'          TCB NAME GOES HERE
         DC    33C' '                 FILLER FOR JSMESSG
*
*********************************************************************
* MSDA (MASTER SCHEDULER RESIDENT DATA AREA)
*********************************************************************
*
         ORG   FIRST4K+((*-FIRST4K+31)/32*32) NICE ALIGNMENT
MYMSDA   DC    CL4'MSDA'              IDENT FOR MSDA
LOCMECB  DC    X'7F',C'DIS'           MECB
LOCMAXI  DC    F'1'                   MAX # INITIATORS
LOCCURI  DC    F'0'                   # INITIATORS RUNNING
         DC    XL4'15000'             LOAD ADDRESS NEXT USER PGM
KEY      DC    X'58'                  KEY 5 FETCH PROTECT ON
         DC    C'5'                   PAD CHARACTER
         ORG   MYMSDA+(MSDAFFLO-MSDA) GO TO LOCATION FOR MSDAFFL0
         DC    D'1,-2,+3,-4'          DEFINE MSDAFFL0-MSDAFFL6
*
** END OF MSDA **
*
         ORG FIRST4K+X'20000'         CREATE ADDRESSABLE SPACE
HIGHEST  DC    CL8'HIGHEST'           HIGHEST address
         END   FIRST4K                END OF THE 1ST 4K CSECT
/*
//*
//FT05F001 DD DSN=T90RPR1.CS468PUB.OBJLIB(PARM1111),DISP=SHR
//*
//* ABOVE IS ONE 'PARM' CARD THAT IS READ IN BY NIP PRIOR TO THE
//* LOADING OF THE TEST PROGRAM.
//*
// DD DSN=T90RPR1.CS468PUB.OBJLIB(SOSPGMA0),DISP=SHR
//*
//* ABOVE IS THE OBJECT MODULE OF THE USER PROGRAM THAT IS TO BE
//* LOADED BY THE USE OF SVC 8.
//*
// DD DSN=SYS1.MACLIB(BCS),DISP=SHR
//*
//* ABOVE IS THE INPUT DATA THAT IS TO BE READ BY USER PROGRAM
//* 'OBJMOD7' USING OBJMOD7-S CALLS TO SVC 0.
//
